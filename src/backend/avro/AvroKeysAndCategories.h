/**
 *  \file RMF/internal/SharedData.h
 *  \brief Handle read/write of Model data from/to files.
 *
 *  Copyright 2007-2012 IMP Inventors. All rights reserved.
 *
 */

#ifndef RMF_INTERNAL_AVRO_KEYS_AND_CATEGORIES_H
#define RMF_INTERNAL_AVRO_KEYS_AND_CATEGORIES_H

#include <RMF/config.h>
#include <RMF/internal/SharedData.h>
#include <RMF/infrastructure_macros.h>
#include <RMF/constants.h>
#include <RMF/internal/map.h>
#include <RMF/internal/set.h>
#include "AvroSharedData.types.h"

namespace RMF {
  namespace internal {

    class AvroKeysAndCategories: public SharedData {
      typedef map<Category, std::string> CategoryNameMap;
      typedef map<std::string, Category> NameCategoryMap;
      CategoryNameMap category_name_map_;
      NameCategoryMap name_category_map_;
      struct KeyData {
        std::string name;
        Category category;
        int type_index;
      };
      typedef map<unsigned int, KeyData> KeyDataMap;
      KeyDataMap key_data_map_;
      typedef map<std::string, unsigned int> NameKeyInnerMap;
      typedef map<Category, NameKeyInnerMap> NameKeyMap;
      NameKeyMap name_key_map_;

      vector<std::string> node_keys_;
      std::string frame_key_;

    public:
      std::string get_key_name(unsigned int id) const {
        return key_data_map_.find(id)->second.name;
      }
      Category get_category(unsigned int id) const {
        return key_data_map_.find(id)->second.category;
      }
      using SharedData::get_category;

      template <class TypeTraits>
    Key<TypeTraits>
        get_key_helper(Category category,
                       std::string name) {
        typename NameKeyInnerMap::const_iterator it
          = name_key_map_[category].find(name);
        if (it == name_key_map_[category].end()) {
          unsigned int id= key_data_map_.size();
          key_data_map_[id].name=name;
          key_data_map_[id].category=category;
          key_data_map_[id].type_index=TypeTraits::get_index();
          name_key_map_[category][name]=id;
          RMF_INTERNAL_CHECK(get_key_helper<TypeTraits>(category,
                                                        name)
                             == Key<TypeTraits>(id),
                             "Keys don't match");
          return Key<TypeTraits>(id);
        } else {
          int id= it->second;
          RMF_INTERNAL_CHECK(name==it->first,
                             "Odd names");
          return Key<TypeTraits>(id);
        }
      }

      const std::string &get_node_string(int node) const {
        if (node==-1) return frame_key_;
        return node_keys_[node];
      }

      template <class TypeTraits>
        const std::string &get_key_string(Key<TypeTraits> k) const {
        RMF_INTERNAL_CHECK(k.get_id() >=0,
                           "Bad key");
        return key_data_map_.find(k.get_id())->second.name;
      }

      void clear_node_keys() {
        node_keys_.clear();
      }

      void add_node_key() {
        std::ostringstream oss;
        oss << node_keys_.size();
        node_keys_.push_back(oss.str());
      }

      std::string get_category_name(Category kc) const  {
        return category_name_map_.find(kc)->second;
      }

    Categories get_categories() const {
      Categories ret;
      for (CategoryNameMap::const_iterator
             it= category_name_map_.begin(); it != category_name_map_.end();
           ++it) {
        ret.push_back(it->first);
      }
      return ret;
    }
      Category get_category(std::string name){
        NameCategoryMap::iterator it=name_category_map_.find(name);
        if (it== name_category_map_.end()) {
          unsigned int id= category_name_map_.size();
          Category ret(id);
          name_category_map_[name]=ret;
          category_name_map_[ret]=name;
          return ret;
        } else {
          return it->second;
        }
      }


      AvroKeysAndCategories(std::string path): SharedData(path){}

    };

  } // namespace internal
} /* namespace RMF */

#endif /* RMF_INTERNAL_AVRO_KEYS_AND_CATEGORIES_H */
